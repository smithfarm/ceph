Submitting Patches to Ceph - Backports
======================================

Most likely you're reading this because you intend to submit a GitHub pull
request ("PR") targeting one of the `stable branches`_ ("nautilus", etc.) at
https://github.com/ceph/ceph.

.. _`stable branches`: https://docs.ceph.com/docs/master/releases/#active-releases

Before you open that PR, read this entire document or, at the very least,
the following three sections:

* `Justify your backport`_
* `Cherry-picking rules`_
* `Conflict resolution`_


.. contents::
   :depth: 3


Justify your backport
---------------------

As a courtesy to the people who will review your backport, you are encouraged to
provide a justification for it. It is especially important to provide such
a justification in cases when the backport could be seen as introducing, into
a stable branch, code that is not obviously related to a particular bug or
issue.

Here are some questions such a justification might be expected to answer:

1. what bug is fixed
2. why this fix is the minimal way to do it
3. why does this need to be fixed in <release>

The justification can be placed wherever you deem appropriate - in the backport
PR description, or in `backport tracker issues`_, or even in the master tracker
issue.

Rationale: Every modification of a stable branch carries a certain risk of
introducing a regression. To minimize this risk, backports should be as
straightforward and narrowly-targeted as possible. As a stable release series
ages, the importance of explicitly justifying backports rises.


Cherry-picking rules
--------------------

The following rules, which have been codified from "best practices" developed
over years of backporting, apply to the actual backport implementation:

* all fixes should land in master first
* commits to stable branches should be cherry-picked from master
* before starting to cherry-pick a commit or set of commits, grep the master git history for the SHA1 of each master commit (using ``git log --grep <short_sha1>``) to check for follow-up fixes. Include any follow-up fixes found in the set of commits to be cherry-picked.
* cherry-picks must be done using ``git cherry-pick -x``
* if a commit could not be cherry-picked from master, the commit message must explain why that was not possible
* the commit message generated by ``git cherry-pick -x`` must not be modified, except to append a "Conflicts" section (in other words, any editing of the commit message should be limited to the part below the "(cherry picked from commit ...)" line generated by git)
* the "Conflicts" section is required in all cherry-picked commits that required manual revision, and must mention all files that were revised, regardless of whether the revisions were needed to resolve conflicts flagged by git or for some other reason
* if a change is to be backported to multiple stable branches, the master PR should have an an associated tracker issue (the "master tracker", or "parent tracker") - if it is missing, create it so the backports can be tracked

For more information on tracker issues, see `Tracker workflow`_ and 
`Backport tracker issues`_. 

For more information on conflict resolution and writing the "Conflicts" section
of the commit message, see `Conflict resolution`_.

Providing a justification and complying with these `Cherry-picking rules`_ will
make your backport easier for reviewers to understand. Non-compliance creates
additional work for reviewers and may block acceptance of your backport PR.

Notes on the cherry-picking rules
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What does "all fixes should land in master first" mean? What if I just need to
fix the issue in <release>?

As the person fixing the issue, you are required to first check whether the
issue exists in master. If it does, then the proper course of action is to
create a master tracker (see `Tracker workflow`_) and fix the issue in master,
first. Once the fix has been merged to master, then (and only then) it can be
cherry-picked to the stable branches that have the issue.

What if the issue exists in a stable branch, but not in master?

There are several possibilities. First, determine which one applies in your
specific case:

1. the issue is a regression introduced into the stable branch by a bad backport
2. the issue was fixed in master by some massive refactoring that cannot be backported
3. the issue was already fixed in master by a cherry-pickable commit

In possibilities 1 and 2, it's permissible to fix the issue directly in the most
recent stable branch, subject to the rule "if a commit could not be
cherry-picked from master, the commit message must explain why that was not
possible". Once the fix has landed in the most recent stable branch, then (and
only then) it can be cherry-picked from there to older stable branches, provided
they have been confirmed to also have the issue. (See `Justify your backport`_.)

In case 3, the issue should be handled like any other backport - read on.

Once I open a master PR, I can go ahead and open backport PRs, right? After all,
my primary objective is to get the fix into a stable branch.

No, you have to wait until the master PR is merged, because "cherry-picked
commits must refer to a SHA1 that is in master". Even if you are confident your
master PR will eventually be merged, you cannot be sure you will not need to
revise and rebase it in order to get it through review and testing. Creating
backport PRs before the master PR is merged opens up the possibility that the
cherry-picks will refer to SHA1s that are not present in master.


Conflict resolution
-------------------

If `git cherry-pick -x` (whether run manually or via `the ceph-backport.sh
script`_) reports conflicts, you will need to resolve them manually.

Once the conflicts are resolved, complete the cherry-pick ::

    git cherry-pick --continue

Git will present a draft commit message with a "Conflicts" section.

The purpose of the "Conflicts" section is to call reviewers' attention to the
fact that manual revision of the cherry-pick was necessary.

Unfortunately, in recent versions of git, the Conflicts section is commented
out. Since the Conflicts section is mandatory for Ceph backports that require
manual editing of any kind, you will need to uncomment the entire "Conflicts"
section of the commit message before committing the cherry-pick. You can also
include commentary on what the conflicts were and how you resolved them. For
example::

    Conflicts:
            src/foo/bar.cc
    - mimic does not have blatz; use bonzor instead

Manual changes might be necessary even when a commit cherry-picks cleanly. In
this case, a "Conflicts" section should be created manually. Also, when
resolving conflicts for a cherry-pick, you might know that additional changes
are necessary in the stable branch to make the commit work there. In that case,
make the changes while resolving the cherry-pick conflicts, and describe these
additional changes in the "Conflicts" section.

Rationale: Though there is a slight semantic difference between conflicts
reported by git and "conflicts" that arise due to manual editing after a clean
cherry-pick, the Conflicts section is where any and all manual revisions are
declared, regardless of what precipitated the need for modification.

When preparing the commit message, leave everything before the "(cherry picked
from commit ...)" line unchanged. Modifying the original commit message casts
doubt on the entire cherry-pick operation and is never a good idea. Any
modifications you make should be limited to the part following that line. Here
is an example::

    osd: check batlo before setting blatz

    Setting blatz requires special precautions. Check batlo first.
    
    Fixes: https://tracker.ceph.com/issues/99999
    Signed-off-by: Random J Developer <random@developer.example.com>
    (cherry picked from commit 01d73020da12f40ccd95ea1e49cfcf663f1a3a75)
    
    Conflicts:
    	src/osd/batlo.cc
    - add_batlo_check has an extra arg in newer code

Since the entire first section, up to the line "(cherry picked from commit
...)", is taken verbatim from the master commit, the ``Fixes`` line points to
the master issue, not the backport issue. This is expected, and is not
a problem.

There are cases when a commit cannot be cherry-picked at all, for example
because it touches code that was moved to a different file. Often, these cases
can be handled just like a cherry-pick with conflicts: just explain what you did
in the "Conflicts section, as usual. For example::

    Conflicts:
        src/osd/new/location/batlo.cc
    - code was moved; manually cherry-picked the changes into src/osd/batlo.cc


Tracker workflow
----------------

Any change that is to be backported to multiple stable branches should have
an associated tracker issue at https://tracker.ceph.com. (If a change is only to
be backported to the most recent stable branch, the tracker issue is optional.)

For fixes already merged to master, a tracker issue may already be there. Look
for lines that start with ``Fixes:``, both inside the commits and in the master
PR's description and comments. If the master PR has already been merged and
there is no associated master tracker issue, you can create a master tracker
issue and fill in the fields as described below.

This master tracker issue should be in the "Bug" or "Feature" trackers of the
relevant subproject under the "Ceph" parent project (or in the "Ceph" project
itself if none of the subprojects are a good fit). The stable branches to which
the master changes are to be cherry-picked should be listed in the "Backport"
field. For example::

    Backport: mimic, nautilus

Once the PR targeting master is open, add the PR number assigned by GitHub to
the tracker issue. Use the "Pull request ID" field for this purpose. For
example, if the PR is https://github.com/ceph/ceph/pull/99999, fill out the
field as follows::

    Pull request ID: 99999

Once the master PR has been merged, after checking that the change really needs
to be backported and that the Backport field has been populated, change the
master tracker issue's ``Status`` field to "Pending Backport".

    Status: Pending Backport

If you do not have sufficient permissions to modify any field of the tracker
issue, just add a comment to the tracker describing what changes you would like
to be made. Someone with permissions will update the tracker issue on your
behalf.

For straightforward backports, that's all you, the developer of the fix, need to
do. Volunteers from the `Stable Releases and Backports team`_ will proceed to
create Backport issues to track the necessary backports and stage the backports
by opening GitHub PRs with the cherry-picks. If you don't want to wait, and
provided you have sufficient permissions at https://tracker.ceph.com, read on:
you may create `Backport tracker issues` yourself, and `opening a backport PR`_
yourself is allowed and, indeed, encouraged.


Backport tracker issues
-----------------------

To track backporting efforts, "backport tracker issues" can be created from
a parent "master tracker issue". The master tracker issue is described in the
previous section, `Tracker workflow`_. This section focuses on the issues in the
Backport tracker, which are used to track the individual backports.

There is a common misconception that a backport tracker issue is required before
a backport PR will be considered. This is not true. In particular, it is not
desirable to create issues in the Backport tracker manually. They should be
created by running `the backport-create-issue script`_ on a master tracker issue
that has undergone the `Tracker workflow`_.

Volunteers from the `Stable Releases and Backports team`_ periodically run
`the backport-create-issue script`_ and create any backport tracker issues that
are needed. Since this does not happen immediately, you might be tempted to
forge ahead and create the backport issues yourself by clicking on elements in
the Redmine GUI. Please don't do that: it is difficult (bordering on impossible)
to get all the fields correct when creating backport issues manually, and why
even try when there is a script that gets it right every time?

The backport-create-issue script
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The script used to create backport issues is located at
``src/script/backport-create-issue`` in the master branch. Though there might be
an older version of this script in a stable branch, use the most recent version
from master for best results.

Setting up the script requires a small up-front time investment. Once that is
done, creating backport issues for a given master issue becomes trivial.

Before you run the script, install the dependencies. The dependencies are:

* python3
* python-redmine

Python 3 should already be present on any recent Linux installation. The second
dependency, `python-redmine`_, can be obtained from PyPi::

    pip3 install --user python-redmine

.. _`python-redmine`: https://pypi.org/project/python-redmine/

Then, copy the script to somewhere in your PATH and try to run it::

    backport-create-issue --help

This should produce a usage message.

Finally, run the script to actually create the Backport issues::

    backport-create-issue --user <tracker_username> --password <tracker_password> 99999

The script needs to know your https://tracker.ceph.com credentials in order to
authenticate to Redmine. In lieu of providing your literal username and password
on the command line, you could also obtain a REST API key ("My account" -> "API
access key") and run the script like so::

    backport-create-issue --key <tracker_api_key> 99999


.. _`stage backports`:
.. _`stage the backport`:
.. _`staging a backport`:

Opening a backport PR
---------------------

In the past, much time was lost, and much frustration caused, by the necessity
of staging backports manually. Now, fortunately, there is a script available
which automates the process and takes away most of the guesswork.

Even if you decide not to use the script, be sure to read the
`Conflict resolution`_ section before you start cherry-picking.

The ceph-backport.sh script
^^^^^^^^^^^^^^^^^^^^^^^^^^^

As with `backport tracker issues`_, the process of opening a backport PR
is difficult - though not impossible - to get right if you're doing it manually,
and becomes tedious if you do it more than once in a while.

The ``ceph-backport.sh`` script automates the process. It cherry-picks
the commits from the master PR (though it does not resolve conflicts), it opens
the GitHub backport PR, and it cross-links the GitHub backport PR with the
backport tracker issue. Even if you prepare the backport branch with the
cherry-picks in it manually, the script can still automate the rest of the
work.

The script is located at ``src/script/ceph-backport.sh`` in the ``master``
branch. Though there might be an older version of this script in a stable
branch, do not use it. Only use the most recent version from master.

This is just a bash script, so the only dependency is ``bash`` itself, but it
does need to be run in the top level of a local clone of ``ceph/ceph.git``.
A small up-front time investment is required to get the script working in your
environment. This is because the script needs to autenticate itself (i.e., as
you) in order to use the GitHub and Redmine REST API services.

The script is self-documenting. Just run the script and proceed from there.

To determine whether the script is capable of performing a backport, run::

    ceph-backport.sh --setup

Once you have this saying "Overall setup is OK", you have two options for
staging the backport: either leave everything to the script, or prepare the
backport branch yourself and use the script only for creating the PR and
updating the Backport tracker issue.

In either case, the script should be run by passing it the number of the
backport tracker issue::

    ceph-backport.sh 55555

If you prefer to prepare the backport branch yourself, use the same naming
convention as the script uses, i.e.::

    wip-<backport_issue_number>-<name_of_stable_branch>

For example, if the Backport tracker issue number is 55555 and the backport is
targeting the stable branch "nautilus", the backport branch would be named::

    wip-55555-nautilus

The script will see that the backport branch already exists, and use it.


Labelling of backport PRs
-------------------------

You may notice that PRs can be labelled in various ways. If GitHub does not
allow you to set labels, do not be concerned. Someone with sufficient
permissions will determine which labels are needed and add them.


Reviewing, testing, and merging of backport PRs
-----------------------------------------------

Once your backport PR is open, the `Stable Releases and Backports team` will
take care of getting the PR labelled, reviewed, tested and - assuming all of that
goes well - merged.

If you would like to facilitate this process, you can solicit reviews and run
integration tests on the PR. In this case, add comments to the PR describing the
tests you ran and their results.

Even if you have sufficient GitHub permissions to merge a backport PR and you
think it's OK to merge it, do *not* merge it yourself. Uncontrolled merging to
stable branches unnecessarily complicates the release preparation process, which
is done by volunteers.


Stable Releases and Backports team
----------------------------------

Ceph has a `Stable Releases and Backports`_ team, staffed by volunteers,
which is charged with maintaining the stable releases and backporting bugfixes
from the master branch to them. That team maintains a wiki, accessible by
clicking the `Stable Releases and Backports`_ link, which describes various
workflows in the backporting lifecycle.

.. _`Stable Releases and Backports`: http://tracker.ceph.com/projects/ceph-releases/wiki

If you have any questions regarding backporting, feel free to address them to
the members of that team.
